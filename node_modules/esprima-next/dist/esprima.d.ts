interface EsprimaError extends Error {
    name: string;
    message: string;
    index: number;
    lineNumber: number;
    column: number;
    description: string;
}

declare enum Syntax {
    AssignmentExpression = "AssignmentExpression",
    AssignmentPattern = "AssignmentPattern",
    ArrayExpression = "ArrayExpression",
    ArrayPattern = "ArrayPattern",
    ArrowFunctionExpression = "ArrowFunctionExpression",
    AwaitExpression = "AwaitExpression",
    BlockStatement = "BlockStatement",
    BinaryExpression = "BinaryExpression",
    BreakStatement = "BreakStatement",
    CallExpression = "CallExpression",
    CatchClause = "CatchClause",
    ChainExpression = "ChainExpression",
    ClassBody = "ClassBody",
    ClassDeclaration = "ClassDeclaration",
    ClassExpression = "ClassExpression",
    ConditionalExpression = "ConditionalExpression",
    ContinueStatement = "ContinueStatement",
    Decorator = "Decorator",
    DoWhileStatement = "DoWhileStatement",
    DebuggerStatement = "DebuggerStatement",
    EmptyStatement = "EmptyStatement",
    ExportAllDeclaration = "ExportAllDeclaration",
    ExportDefaultDeclaration = "ExportDefaultDeclaration",
    ExportNamedDeclaration = "ExportNamedDeclaration",
    ExportSpecifier = "ExportSpecifier",
    ExpressionStatement = "ExpressionStatement",
    ForStatement = "ForStatement",
    ForOfStatement = "ForOfStatement",
    ForInStatement = "ForInStatement",
    FunctionDeclaration = "FunctionDeclaration",
    FunctionExpression = "FunctionExpression",
    Identifier = "Identifier",
    IfStatement = "IfStatement",
    ImportAttribute = "ImportAttribute",
    ImportExpression = "ImportExpression",
    ImportDeclaration = "ImportDeclaration",
    ImportDefaultSpecifier = "ImportDefaultSpecifier",
    ImportNamespaceSpecifier = "ImportNamespaceSpecifier",
    ImportSpecifier = "ImportSpecifier",
    Literal = "Literal",
    LabeledStatement = "LabeledStatement",
    LogicalExpression = "LogicalExpression",
    MemberExpression = "MemberExpression",
    MetaProperty = "MetaProperty",
    MethodDefinition = "MethodDefinition",
    NewExpression = "NewExpression",
    ObjectExpression = "ObjectExpression",
    ObjectPattern = "ObjectPattern",
    Program = "Program",
    Property = "Property",
    PrivateIdentifier = "PrivateIdentifier",
    RestElement = "RestElement",
    ReturnStatement = "ReturnStatement",
    SequenceExpression = "SequenceExpression",
    SpreadElement = "SpreadElement",
    StaticBlock = "StaticBlock",
    Super = "Super",
    SwitchCase = "SwitchCase",
    SwitchStatement = "SwitchStatement",
    TaggedTemplateExpression = "TaggedTemplateExpression",
    TemplateElement = "TemplateElement",
    TemplateLiteral = "TemplateLiteral",
    ThisExpression = "ThisExpression",
    ThrowStatement = "ThrowStatement",
    TryStatement = "TryStatement",
    UnaryExpression = "UnaryExpression",
    UpdateExpression = "UpdateExpression",
    VariableDeclaration = "VariableDeclaration",
    VariableDeclarator = "VariableDeclarator",
    WhileStatement = "WhileStatement",
    WithStatement = "WithStatement",
    YieldExpression = "YieldExpression"
}

type ArgumentListElement = Expression | SpreadElement;
type ArrayExpressionElement = Expression | SpreadElement | null;
type ArrayPatternElement = AssignmentPattern | BindingIdentifier | BindingPattern | RestElement | null;
type BindingPattern = ArrayPattern | ObjectPattern;
type BindingIdentifier = Identifier;
type ChainElement = CallExpression | MemberExpression | MemberExpression;
type Class = ClassDeclaration | ClassExpression;
type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration | ImportDeclaration | ExportDeclaration;
type ExportableDefaultDeclaration = BindingIdentifier | BindingPattern | ClassDeclaration | Expression | FunctionDeclaration;
type ExportableNamedDeclaration = AsyncFunctionDeclaration | ClassDeclaration | FunctionDeclaration | VariableDeclaration;
type ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;
type Expression = ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AwaitExpression | BinaryExpression | CallExpression | ChainExpression | ClassExpression | MemberExpression | ConditionalExpression | Identifier | FunctionExpression | Literal | LogicalExpression | NewExpression | ObjectExpression | RegexLiteral | SequenceExpression | MemberExpression | TemplateLiteral | TaggedTemplateExpression | ThisExpression | UnaryExpression | UpdateExpression | YieldExpression | MetaProperty | ImportExpression;
type FunctionParameter = AssignmentPattern | BindingIdentifier | BindingPattern;
type Function = FunctionDeclaration | FunctionExpression | ArrowFunctionExpression;
type ImportDeclarationSpecifier = ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier;
type ObjectExpressionProperty = Property | SpreadElement;
type ObjectPatternProperty = Property | RestElement;
type Statement = BlockStatement | BreakStatement | LabeledStatement | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | Directive | ForStatement | ForInStatement | ForOfStatement | IfStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | VariableDeclaration | WhileStatement | WithStatement | Declaration;
type Pattern = Expression | ObjectPattern | ArrayPattern | Identifier | AssignmentPattern | RestElement;
type PropertyKey = Identifier | Literal | PrivateIdentifier;
type PropertyValue = AssignmentPattern | BindingIdentifier | BindingPattern | FunctionExpression;
type Node = Program | Function | Statement | VariableDeclarator | Expression | Property | PropertyKey | Pattern | SwitchCase | CatchClause | MethodDefinition | Class | ClassBody | ImportDeclaration | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportNamedDeclaration | ExportSpecifier | ExportDefaultDeclaration | ExportAllDeclaration | TemplateElement | Super | ArgumentListElement | PropertyDefinition | StaticBlock | Decorator | ImportAttribute | null;
declare class ArrayExpression {
    readonly type: Syntax.ArrayExpression;
    readonly elements: ArrayExpressionElement[];
    constructor(elements: ArrayExpressionElement[]);
}
declare class ArrayPattern {
    readonly type: Syntax.ArrayPattern;
    readonly elements: ArrayPatternElement[];
    constructor(elements: ArrayPatternElement[]);
}
declare class ArrowFunctionExpression {
    readonly type: Syntax.ArrowFunctionExpression;
    readonly id: Identifier | null;
    readonly params: FunctionParameter[];
    readonly body: BlockStatement | Expression;
    readonly generator: boolean;
    readonly expression: boolean;
    readonly async: boolean;
    constructor(params: FunctionParameter[], body: BlockStatement | Expression, expression: boolean, isAsync: boolean);
}
declare class AssignmentExpression {
    readonly type: Syntax.AssignmentExpression;
    readonly operator: string;
    readonly left: Expression;
    readonly right: Expression;
    constructor(operator: string, left: Expression, right: Expression);
}
declare class AssignmentPattern {
    readonly type: Syntax.AssignmentPattern;
    readonly left: BindingIdentifier | BindingPattern;
    readonly right: Expression;
    constructor(left: BindingIdentifier | BindingPattern, right: Expression);
}
declare class AsyncFunctionDeclaration {
    readonly type: Syntax.FunctionDeclaration;
    readonly id: Identifier | null;
    readonly params: FunctionParameter[];
    readonly body: BlockStatement;
    readonly generator: boolean;
    readonly expression: boolean;
    readonly async: boolean;
    constructor(id: Identifier | null, params: FunctionParameter[], body: BlockStatement, generator: boolean);
}
declare class AwaitExpression {
    readonly type: Syntax.AwaitExpression;
    readonly argument: Expression;
    constructor(argument: Expression);
}
declare class BigIntLiteral {
    readonly type: Syntax.Literal;
    readonly value: null | bigint;
    readonly raw: string;
    readonly bigint: string;
    constructor(value: null | bigint, raw: string, bigint: string);
}
declare class BinaryExpression {
    readonly type: Syntax.BinaryExpression;
    readonly operator: string;
    readonly left: Expression | PrivateIdentifier;
    readonly right: Expression;
    constructor(operator: string, left: Expression | PrivateIdentifier, right: Expression);
}
declare class BlockStatement {
    readonly type: Syntax.BlockStatement;
    readonly body: Statement[];
    constructor(body: any);
}
declare class BreakStatement {
    readonly type: Syntax.BreakStatement;
    readonly label: Identifier | null;
    constructor(label: Identifier | null);
}
declare class CallExpression {
    readonly type: Syntax.CallExpression;
    readonly callee: Expression | ImportExpression;
    readonly arguments: ArgumentListElement[];
    readonly optional: boolean;
    constructor(callee: Expression | ImportExpression, args: ArgumentListElement[], optional: boolean);
}
declare class CatchClause {
    readonly type: Syntax.CatchClause;
    readonly param: BindingIdentifier | BindingPattern | null;
    readonly body: BlockStatement;
    constructor(param: BindingIdentifier | BindingPattern | null, body: BlockStatement);
}
declare class ChainExpression {
    readonly type: Syntax.ChainExpression;
    readonly expression: ChainElement;
    constructor(expression: ChainElement);
}
declare class ClassBody {
    readonly type: Syntax.ClassBody;
    readonly body: (MethodDefinition | PropertyDefinition | StaticBlock)[];
    constructor(body: (MethodDefinition | PropertyDefinition | StaticBlock)[]);
}
declare class ClassDeclaration {
    readonly type: Syntax.ClassDeclaration;
    readonly id: Identifier | null;
    readonly superClass: Identifier | null;
    readonly body: ClassBody;
    readonly decorators: Decorator[] | null;
    constructor(id: Identifier | null, superClass: Identifier | null, body: ClassBody, decorators: Decorator[] | null);
}
declare class ClassExpression {
    readonly type: Syntax.ClassExpression;
    readonly id: Identifier | null;
    readonly superClass: Identifier | null;
    readonly body: ClassBody;
    readonly decorators: Decorator[] | null;
    constructor(id: Identifier | null, superClass: Identifier | null, body: ClassBody, decorators: Decorator[] | null);
}
declare class ConditionalExpression {
    readonly type: Syntax.ConditionalExpression;
    readonly test: Expression;
    readonly consequent: Expression;
    readonly alternate: Expression;
    constructor(test: Expression, consequent: Expression, alternate: Expression);
}
declare class ContinueStatement {
    readonly type: Syntax.ContinueStatement;
    readonly label: Identifier | null;
    constructor(label: Identifier | null);
}
declare class DebuggerStatement {
    readonly type: Syntax.DebuggerStatement;
    constructor();
}
declare class Decorator {
    readonly type: Syntax.Decorator;
    readonly expression: Expression;
    constructor(expression: Expression);
}
declare class Directive {
    readonly type: Syntax.ExpressionStatement;
    readonly expression: Expression;
    readonly directive: string;
    constructor(expression: Expression, directive: string);
}
declare class DoWhileStatement {
    readonly type: Syntax.DoWhileStatement;
    readonly body: Statement;
    readonly test: Expression;
    constructor(body: Statement, test: Expression);
}
declare class EmptyStatement {
    readonly type: Syntax.EmptyStatement;
    constructor();
}
declare class ExportAllDeclaration {
    readonly type: Syntax.ExportAllDeclaration;
    readonly source: Literal;
    readonly exported: Identifier | Literal | null;
    readonly assertions: ImportAttribute[] | null;
    constructor(source: Literal, exported: Identifier | Literal | null, assertions: ImportAttribute[] | null);
}
declare class ExportDefaultDeclaration {
    readonly type: Syntax.ExportDefaultDeclaration;
    readonly declaration: ExportableDefaultDeclaration;
    constructor(declaration: ExportableDefaultDeclaration);
}
declare class ExportNamedDeclaration {
    readonly type: Syntax.ExportNamedDeclaration;
    readonly declaration: ExportableNamedDeclaration | null;
    readonly specifiers: ExportSpecifier[];
    readonly source: Literal | null;
    readonly assertions: ImportAttribute[] | null;
    constructor(declaration: ExportableNamedDeclaration | null, specifiers: ExportSpecifier[], source: Literal | null, assertions: ImportAttribute[] | null);
}
declare class ExportSpecifier {
    readonly type: Syntax.ExportSpecifier;
    readonly exported: Identifier | Literal;
    readonly local: Identifier | Literal;
    constructor(local: Identifier | Literal, exported: Identifier | Literal);
}
declare class ExpressionStatement {
    readonly type: Syntax.ExpressionStatement;
    readonly expression: Expression;
    constructor(expression: Expression);
}
declare class ForInStatement {
    readonly type: Syntax.ForInStatement;
    readonly left: Expression;
    readonly right: Expression;
    readonly body: Statement;
    readonly each: boolean;
    constructor(left: Expression, right: Expression, body: Statement);
}
declare class ForOfStatement {
    readonly type: Syntax.ForOfStatement;
    readonly await: boolean;
    readonly left: Expression;
    readonly right: Expression;
    readonly body: Statement;
    constructor(left: Expression, right: Expression, body: Statement, _await: boolean);
}
declare class ForStatement {
    readonly type: Syntax.ForStatement;
    readonly init: Expression | null;
    readonly test: Expression | null;
    readonly update: Expression | null;
    body: Statement;
    constructor(init: Expression | null, test: Expression | null, update: Expression | null, body: Statement);
}
declare class FunctionDeclaration {
    readonly type: Syntax.FunctionDeclaration;
    readonly id: Identifier | null;
    readonly params: FunctionParameter[];
    readonly body: BlockStatement;
    readonly generator: boolean;
    readonly expression: boolean;
    readonly async: boolean;
    constructor(id: Identifier | null, params: FunctionParameter[], body: BlockStatement, generator: boolean);
}
declare class FunctionExpression {
    readonly type: Syntax.FunctionExpression;
    readonly id: Identifier | null;
    readonly params: FunctionParameter[];
    readonly body: BlockStatement;
    readonly generator: boolean;
    readonly expression: boolean;
    readonly async: boolean;
    constructor(id: Identifier | null, params: FunctionParameter[], body: BlockStatement, generator: boolean, isAsync: boolean);
}
declare class Identifier {
    readonly type: Syntax.Identifier;
    readonly name: string;
    constructor(name: any);
}
declare class IfStatement {
    readonly type: Syntax.IfStatement;
    readonly test: Expression;
    readonly consequent: Statement;
    readonly alternate: Statement | null;
    constructor(test: Expression, consequent: Statement, alternate: Statement | null);
}
declare class ImportAttribute {
    readonly type: Syntax.ImportAttribute;
    readonly key: Identifier | Literal;
    readonly value: Literal;
    constructor(key: Identifier | Literal, value: Literal);
}
declare class ImportExpression {
    readonly type: Syntax.ImportExpression;
    readonly source: Expression;
    readonly attributes: Expression | null;
    constructor(source: any, attributes: Expression | null);
}
declare class ImportDeclaration {
    readonly type: Syntax.ImportDeclaration;
    readonly specifiers: ImportDeclarationSpecifier[];
    readonly source: Literal;
    readonly assertions: ImportAttribute[] | null;
    constructor(specifiers: any, source: any, assertions: ImportAttribute[] | null);
}
declare class ImportDefaultSpecifier {
    readonly type: Syntax.ImportDefaultSpecifier;
    readonly local: Identifier;
    constructor(local: Identifier);
}
declare class ImportNamespaceSpecifier {
    readonly type: Syntax.ImportNamespaceSpecifier;
    readonly local: Identifier;
    constructor(local: Identifier);
}
declare class ImportSpecifier {
    readonly type: Syntax.ImportSpecifier;
    readonly local: Identifier;
    readonly imported: Identifier | Literal;
    constructor(local: Identifier, imported: Identifier | Literal);
}
declare class LabeledStatement {
    readonly type: Syntax.LabeledStatement;
    readonly label: Identifier;
    readonly body: Statement;
    constructor(label: Identifier, body: Statement);
}
declare class Literal {
    readonly type: Syntax.Literal;
    readonly value: boolean | number | string | null;
    readonly raw: string;
    constructor(value: boolean | number | string | null, raw: string);
}
declare class LogicalExpression {
    readonly type: Syntax.LogicalExpression;
    readonly operator: string;
    readonly left: Expression;
    readonly right: Expression;
    constructor(operator: string, left: Expression, right: Expression);
}
declare class MemberExpression {
    readonly type: Syntax.MemberExpression;
    readonly computed: boolean;
    readonly object: Expression;
    readonly property: Expression | PrivateIdentifier;
    readonly optional: boolean;
    constructor(computed: boolean, object: Expression, property: Expression, optional: boolean);
}
declare class MetaProperty {
    readonly type: Syntax.MetaProperty;
    readonly meta: Identifier;
    readonly property: Identifier;
    constructor(meta: Identifier, property: Identifier);
}
declare class MethodDefinition {
    readonly type: Syntax.MethodDefinition;
    readonly key: Expression | PrivateIdentifier | null;
    readonly computed: boolean;
    readonly value: FunctionExpression | null;
    readonly kind: string;
    readonly static: boolean;
    readonly decorators: Decorator[] | null;
    constructor(key: Expression | PrivateIdentifier | null, computed: boolean, value: FunctionExpression | null, kind: string, isStatic: boolean, decorators: Decorator[] | null);
}
declare class Module {
    readonly type: Syntax.Program;
    readonly body: Statement[];
    readonly sourceType: string;
    constructor(body: Statement[]);
}
declare class NewExpression {
    readonly type: Syntax.NewExpression;
    readonly callee: Expression;
    readonly arguments: ArgumentListElement[];
    constructor(callee: Expression, args: ArgumentListElement[]);
}
declare class ObjectExpression {
    readonly type: Syntax.ObjectExpression;
    readonly properties: ObjectExpressionProperty[];
    constructor(properties: ObjectExpressionProperty[]);
}
declare class ObjectPattern {
    readonly type: Syntax.ObjectPattern;
    readonly properties: ObjectPatternProperty[];
    constructor(properties: ObjectPatternProperty[]);
}
declare class PrivateIdentifier {
    readonly type: Syntax.PrivateIdentifier;
    readonly name: string;
    constructor(name: any);
}
declare class Program {
    readonly type: Syntax.Program;
    readonly body: Statement[];
    readonly sourceType: 'script' | 'module';
    constructor(sourceType: 'script' | 'module', body: Statement[]);
}
declare class Property {
    readonly type: Syntax.Property;
    readonly key: PropertyKey;
    readonly computed: boolean;
    readonly value: PropertyValue | null;
    readonly kind: string;
    readonly method: boolean;
    readonly shorthand: boolean;
    constructor(kind: string, key: PropertyKey, computed: boolean, value: PropertyValue | null, method: boolean, shorthand: boolean);
}
declare class PropertyDefinition {
    readonly type: Syntax.Property;
    readonly key: PropertyKey;
    readonly computed: boolean;
    readonly value: PropertyValue | null;
    readonly static: boolean;
    readonly decorators: Decorator[] | null;
    constructor(key: PropertyKey, computed: boolean, value: PropertyValue | null, isStatic: boolean, decorators: Decorator[] | null);
}
declare class RegexLiteral {
    readonly type: Syntax.Literal;
    readonly value: RegExp;
    readonly raw: string;
    readonly regex: {
        pattern: string;
        flags: string;
    };
    constructor(value: RegExp, raw: string, pattern: string, flags: string);
}
declare class RestElement {
    readonly type: Syntax.RestElement;
    readonly argument: BindingIdentifier | BindingPattern;
    constructor(argument: BindingIdentifier | BindingPattern);
}
declare class ReturnStatement {
    readonly type: Syntax.ReturnStatement;
    readonly argument: Expression | null;
    constructor(argument: Expression | null);
}
declare class Script {
    readonly type: Syntax.Program;
    readonly body: Statement[];
    readonly sourceType: string;
    constructor(body: Statement[]);
}
declare class SequenceExpression {
    readonly type: Syntax.SequenceExpression;
    readonly expressions: Expression[];
    constructor(expressions: Expression[]);
}
declare class SpreadElement {
    readonly type: Syntax.SpreadElement;
    readonly argument: Expression;
    constructor(argument: Expression);
}
declare class StaticBlock {
    readonly type: Syntax.StaticBlock;
    readonly body: Statement[];
    constructor(body: any);
}
declare class Super {
    readonly type: Syntax.Super;
    constructor();
}
declare class SwitchCase {
    readonly type: Syntax.SwitchCase;
    readonly test: Expression | null;
    readonly consequent: Statement[];
    constructor(test: Expression, consequent: Statement[]);
}
declare class SwitchStatement {
    readonly type: Syntax.SwitchStatement;
    readonly discriminant: Expression;
    readonly cases: SwitchCase[];
    constructor(discriminant: Expression, cases: SwitchCase[]);
}
declare class TaggedTemplateExpression {
    readonly type: Syntax.TaggedTemplateExpression;
    readonly tag: Expression;
    readonly quasi: TemplateLiteral;
    constructor(tag: Expression, quasi: TemplateLiteral);
}
interface TemplateElementValue {
    cooked: string | null;
    raw: string;
}
declare class TemplateElement {
    readonly type: Syntax.TemplateElement;
    readonly value: TemplateElementValue;
    readonly tail: boolean;
    constructor(value: TemplateElementValue, tail: boolean);
}
declare class TemplateLiteral {
    readonly type: Syntax.TemplateLiteral;
    readonly quasis: TemplateElement[];
    readonly expressions: Expression[];
    constructor(quasis: TemplateElement[], expressions: Expression[]);
}
declare class ThisExpression {
    readonly type: Syntax.ThisExpression;
    constructor();
}
declare class ThrowStatement {
    readonly type: Syntax.ThrowStatement;
    readonly argument: Expression;
    constructor(argument: Expression);
}
declare class TryStatement {
    readonly type: Syntax.TryStatement;
    readonly block: BlockStatement;
    readonly handler: CatchClause | null;
    readonly finalizer: BlockStatement | null;
    constructor(block: BlockStatement, handler: CatchClause | null, finalizer: BlockStatement | null);
}
declare class UnaryExpression {
    readonly type: Syntax.UnaryExpression;
    readonly operator: string;
    readonly argument: Expression;
    readonly prefix: boolean;
    constructor(operator: any, argument: any);
}
declare class UpdateExpression {
    readonly type: Syntax.UpdateExpression;
    readonly operator: string;
    readonly argument: Expression;
    readonly prefix: boolean;
    constructor(operator: any, argument: any, prefix: any);
}
declare class VariableDeclaration {
    readonly type: Syntax.VariableDeclaration;
    readonly declarations: VariableDeclarator[];
    readonly kind: string;
    constructor(declarations: VariableDeclarator[], kind: string);
}
declare class VariableDeclarator {
    readonly type: Syntax.VariableDeclarator;
    readonly id: BindingIdentifier | BindingPattern;
    readonly init: Expression | null;
    constructor(id: BindingIdentifier | BindingPattern, init: Expression | null);
}
declare class WhileStatement {
    readonly type: Syntax.WhileStatement;
    readonly test: Expression;
    readonly body: Statement;
    constructor(test: Expression, body: Statement);
}
declare class WithStatement {
    readonly type: Syntax.WithStatement;
    readonly object: Expression;
    readonly body: Statement;
    constructor(object: Expression, body: Statement);
}
declare class YieldExpression {
    readonly type: Syntax.YieldExpression;
    readonly argument: Expression | null;
    readonly delegate: boolean;
    constructor(argument: Expression | null, delegate: boolean);
}

type nodes_ArgumentListElement = ArgumentListElement;
type nodes_ArrayExpression = ArrayExpression;
declare const nodes_ArrayExpression: typeof ArrayExpression;
type nodes_ArrayExpressionElement = ArrayExpressionElement;
type nodes_ArrayPattern = ArrayPattern;
declare const nodes_ArrayPattern: typeof ArrayPattern;
type nodes_ArrayPatternElement = ArrayPatternElement;
type nodes_ArrowFunctionExpression = ArrowFunctionExpression;
declare const nodes_ArrowFunctionExpression: typeof ArrowFunctionExpression;
type nodes_AssignmentExpression = AssignmentExpression;
declare const nodes_AssignmentExpression: typeof AssignmentExpression;
type nodes_AssignmentPattern = AssignmentPattern;
declare const nodes_AssignmentPattern: typeof AssignmentPattern;
type nodes_AsyncFunctionDeclaration = AsyncFunctionDeclaration;
declare const nodes_AsyncFunctionDeclaration: typeof AsyncFunctionDeclaration;
type nodes_AwaitExpression = AwaitExpression;
declare const nodes_AwaitExpression: typeof AwaitExpression;
type nodes_BigIntLiteral = BigIntLiteral;
declare const nodes_BigIntLiteral: typeof BigIntLiteral;
type nodes_BinaryExpression = BinaryExpression;
declare const nodes_BinaryExpression: typeof BinaryExpression;
type nodes_BindingIdentifier = BindingIdentifier;
type nodes_BindingPattern = BindingPattern;
type nodes_BlockStatement = BlockStatement;
declare const nodes_BlockStatement: typeof BlockStatement;
type nodes_BreakStatement = BreakStatement;
declare const nodes_BreakStatement: typeof BreakStatement;
type nodes_CallExpression = CallExpression;
declare const nodes_CallExpression: typeof CallExpression;
type nodes_CatchClause = CatchClause;
declare const nodes_CatchClause: typeof CatchClause;
type nodes_ChainElement = ChainElement;
type nodes_ChainExpression = ChainExpression;
declare const nodes_ChainExpression: typeof ChainExpression;
type nodes_Class = Class;
type nodes_ClassBody = ClassBody;
declare const nodes_ClassBody: typeof ClassBody;
type nodes_ClassDeclaration = ClassDeclaration;
declare const nodes_ClassDeclaration: typeof ClassDeclaration;
type nodes_ClassExpression = ClassExpression;
declare const nodes_ClassExpression: typeof ClassExpression;
type nodes_ConditionalExpression = ConditionalExpression;
declare const nodes_ConditionalExpression: typeof ConditionalExpression;
type nodes_ContinueStatement = ContinueStatement;
declare const nodes_ContinueStatement: typeof ContinueStatement;
type nodes_DebuggerStatement = DebuggerStatement;
declare const nodes_DebuggerStatement: typeof DebuggerStatement;
type nodes_Declaration = Declaration;
type nodes_Decorator = Decorator;
declare const nodes_Decorator: typeof Decorator;
type nodes_Directive = Directive;
declare const nodes_Directive: typeof Directive;
type nodes_DoWhileStatement = DoWhileStatement;
declare const nodes_DoWhileStatement: typeof DoWhileStatement;
type nodes_EmptyStatement = EmptyStatement;
declare const nodes_EmptyStatement: typeof EmptyStatement;
type nodes_ExportAllDeclaration = ExportAllDeclaration;
declare const nodes_ExportAllDeclaration: typeof ExportAllDeclaration;
type nodes_ExportDeclaration = ExportDeclaration;
type nodes_ExportDefaultDeclaration = ExportDefaultDeclaration;
declare const nodes_ExportDefaultDeclaration: typeof ExportDefaultDeclaration;
type nodes_ExportNamedDeclaration = ExportNamedDeclaration;
declare const nodes_ExportNamedDeclaration: typeof ExportNamedDeclaration;
type nodes_ExportSpecifier = ExportSpecifier;
declare const nodes_ExportSpecifier: typeof ExportSpecifier;
type nodes_ExportableDefaultDeclaration = ExportableDefaultDeclaration;
type nodes_ExportableNamedDeclaration = ExportableNamedDeclaration;
type nodes_Expression = Expression;
type nodes_ExpressionStatement = ExpressionStatement;
declare const nodes_ExpressionStatement: typeof ExpressionStatement;
type nodes_ForInStatement = ForInStatement;
declare const nodes_ForInStatement: typeof ForInStatement;
type nodes_ForOfStatement = ForOfStatement;
declare const nodes_ForOfStatement: typeof ForOfStatement;
type nodes_ForStatement = ForStatement;
declare const nodes_ForStatement: typeof ForStatement;
type nodes_Function = Function;
type nodes_FunctionDeclaration = FunctionDeclaration;
declare const nodes_FunctionDeclaration: typeof FunctionDeclaration;
type nodes_FunctionExpression = FunctionExpression;
declare const nodes_FunctionExpression: typeof FunctionExpression;
type nodes_FunctionParameter = FunctionParameter;
type nodes_Identifier = Identifier;
declare const nodes_Identifier: typeof Identifier;
type nodes_IfStatement = IfStatement;
declare const nodes_IfStatement: typeof IfStatement;
type nodes_ImportAttribute = ImportAttribute;
declare const nodes_ImportAttribute: typeof ImportAttribute;
type nodes_ImportDeclaration = ImportDeclaration;
declare const nodes_ImportDeclaration: typeof ImportDeclaration;
type nodes_ImportDeclarationSpecifier = ImportDeclarationSpecifier;
type nodes_ImportDefaultSpecifier = ImportDefaultSpecifier;
declare const nodes_ImportDefaultSpecifier: typeof ImportDefaultSpecifier;
type nodes_ImportExpression = ImportExpression;
declare const nodes_ImportExpression: typeof ImportExpression;
type nodes_ImportNamespaceSpecifier = ImportNamespaceSpecifier;
declare const nodes_ImportNamespaceSpecifier: typeof ImportNamespaceSpecifier;
type nodes_ImportSpecifier = ImportSpecifier;
declare const nodes_ImportSpecifier: typeof ImportSpecifier;
type nodes_LabeledStatement = LabeledStatement;
declare const nodes_LabeledStatement: typeof LabeledStatement;
type nodes_Literal = Literal;
declare const nodes_Literal: typeof Literal;
type nodes_LogicalExpression = LogicalExpression;
declare const nodes_LogicalExpression: typeof LogicalExpression;
type nodes_MemberExpression = MemberExpression;
declare const nodes_MemberExpression: typeof MemberExpression;
type nodes_MetaProperty = MetaProperty;
declare const nodes_MetaProperty: typeof MetaProperty;
type nodes_MethodDefinition = MethodDefinition;
declare const nodes_MethodDefinition: typeof MethodDefinition;
type nodes_Module = Module;
declare const nodes_Module: typeof Module;
type nodes_NewExpression = NewExpression;
declare const nodes_NewExpression: typeof NewExpression;
type nodes_Node = Node;
type nodes_ObjectExpression = ObjectExpression;
declare const nodes_ObjectExpression: typeof ObjectExpression;
type nodes_ObjectExpressionProperty = ObjectExpressionProperty;
type nodes_ObjectPattern = ObjectPattern;
declare const nodes_ObjectPattern: typeof ObjectPattern;
type nodes_ObjectPatternProperty = ObjectPatternProperty;
type nodes_Pattern = Pattern;
type nodes_PrivateIdentifier = PrivateIdentifier;
declare const nodes_PrivateIdentifier: typeof PrivateIdentifier;
type nodes_Program = Program;
declare const nodes_Program: typeof Program;
type nodes_Property = Property;
declare const nodes_Property: typeof Property;
type nodes_PropertyDefinition = PropertyDefinition;
declare const nodes_PropertyDefinition: typeof PropertyDefinition;
type nodes_PropertyKey = PropertyKey;
type nodes_PropertyValue = PropertyValue;
type nodes_RegexLiteral = RegexLiteral;
declare const nodes_RegexLiteral: typeof RegexLiteral;
type nodes_RestElement = RestElement;
declare const nodes_RestElement: typeof RestElement;
type nodes_ReturnStatement = ReturnStatement;
declare const nodes_ReturnStatement: typeof ReturnStatement;
type nodes_Script = Script;
declare const nodes_Script: typeof Script;
type nodes_SequenceExpression = SequenceExpression;
declare const nodes_SequenceExpression: typeof SequenceExpression;
type nodes_SpreadElement = SpreadElement;
declare const nodes_SpreadElement: typeof SpreadElement;
type nodes_Statement = Statement;
type nodes_StaticBlock = StaticBlock;
declare const nodes_StaticBlock: typeof StaticBlock;
type nodes_Super = Super;
declare const nodes_Super: typeof Super;
type nodes_SwitchCase = SwitchCase;
declare const nodes_SwitchCase: typeof SwitchCase;
type nodes_SwitchStatement = SwitchStatement;
declare const nodes_SwitchStatement: typeof SwitchStatement;
type nodes_TaggedTemplateExpression = TaggedTemplateExpression;
declare const nodes_TaggedTemplateExpression: typeof TaggedTemplateExpression;
type nodes_TemplateElement = TemplateElement;
declare const nodes_TemplateElement: typeof TemplateElement;
type nodes_TemplateLiteral = TemplateLiteral;
declare const nodes_TemplateLiteral: typeof TemplateLiteral;
type nodes_ThisExpression = ThisExpression;
declare const nodes_ThisExpression: typeof ThisExpression;
type nodes_ThrowStatement = ThrowStatement;
declare const nodes_ThrowStatement: typeof ThrowStatement;
type nodes_TryStatement = TryStatement;
declare const nodes_TryStatement: typeof TryStatement;
type nodes_UnaryExpression = UnaryExpression;
declare const nodes_UnaryExpression: typeof UnaryExpression;
type nodes_UpdateExpression = UpdateExpression;
declare const nodes_UpdateExpression: typeof UpdateExpression;
type nodes_VariableDeclaration = VariableDeclaration;
declare const nodes_VariableDeclaration: typeof VariableDeclaration;
type nodes_VariableDeclarator = VariableDeclarator;
declare const nodes_VariableDeclarator: typeof VariableDeclarator;
type nodes_WhileStatement = WhileStatement;
declare const nodes_WhileStatement: typeof WhileStatement;
type nodes_WithStatement = WithStatement;
declare const nodes_WithStatement: typeof WithStatement;
type nodes_YieldExpression = YieldExpression;
declare const nodes_YieldExpression: typeof YieldExpression;
declare namespace nodes {
  export { type nodes_ArgumentListElement as ArgumentListElement, nodes_ArrayExpression as ArrayExpression, type nodes_ArrayExpressionElement as ArrayExpressionElement, nodes_ArrayPattern as ArrayPattern, type nodes_ArrayPatternElement as ArrayPatternElement, nodes_ArrowFunctionExpression as ArrowFunctionExpression, nodes_AssignmentExpression as AssignmentExpression, nodes_AssignmentPattern as AssignmentPattern, nodes_AsyncFunctionDeclaration as AsyncFunctionDeclaration, nodes_AwaitExpression as AwaitExpression, nodes_BigIntLiteral as BigIntLiteral, nodes_BinaryExpression as BinaryExpression, type nodes_BindingIdentifier as BindingIdentifier, type nodes_BindingPattern as BindingPattern, nodes_BlockStatement as BlockStatement, nodes_BreakStatement as BreakStatement, nodes_CallExpression as CallExpression, nodes_CatchClause as CatchClause, type nodes_ChainElement as ChainElement, nodes_ChainExpression as ChainExpression, type nodes_Class as Class, nodes_ClassBody as ClassBody, nodes_ClassDeclaration as ClassDeclaration, nodes_ClassExpression as ClassExpression, nodes_ConditionalExpression as ConditionalExpression, nodes_ContinueStatement as ContinueStatement, nodes_DebuggerStatement as DebuggerStatement, type nodes_Declaration as Declaration, nodes_Decorator as Decorator, nodes_Directive as Directive, nodes_DoWhileStatement as DoWhileStatement, nodes_EmptyStatement as EmptyStatement, nodes_ExportAllDeclaration as ExportAllDeclaration, type nodes_ExportDeclaration as ExportDeclaration, nodes_ExportDefaultDeclaration as ExportDefaultDeclaration, nodes_ExportNamedDeclaration as ExportNamedDeclaration, nodes_ExportSpecifier as ExportSpecifier, type nodes_ExportableDefaultDeclaration as ExportableDefaultDeclaration, type nodes_ExportableNamedDeclaration as ExportableNamedDeclaration, type nodes_Expression as Expression, nodes_ExpressionStatement as ExpressionStatement, nodes_ForInStatement as ForInStatement, nodes_ForOfStatement as ForOfStatement, nodes_ForStatement as ForStatement, type nodes_Function as Function, nodes_FunctionDeclaration as FunctionDeclaration, nodes_FunctionExpression as FunctionExpression, type nodes_FunctionParameter as FunctionParameter, nodes_Identifier as Identifier, nodes_IfStatement as IfStatement, nodes_ImportAttribute as ImportAttribute, nodes_ImportDeclaration as ImportDeclaration, type nodes_ImportDeclarationSpecifier as ImportDeclarationSpecifier, nodes_ImportDefaultSpecifier as ImportDefaultSpecifier, nodes_ImportExpression as ImportExpression, nodes_ImportNamespaceSpecifier as ImportNamespaceSpecifier, nodes_ImportSpecifier as ImportSpecifier, nodes_LabeledStatement as LabeledStatement, nodes_Literal as Literal, nodes_LogicalExpression as LogicalExpression, nodes_MemberExpression as MemberExpression, nodes_MetaProperty as MetaProperty, nodes_MethodDefinition as MethodDefinition, nodes_Module as Module, nodes_NewExpression as NewExpression, type nodes_Node as Node, nodes_ObjectExpression as ObjectExpression, type nodes_ObjectExpressionProperty as ObjectExpressionProperty, nodes_ObjectPattern as ObjectPattern, type nodes_ObjectPatternProperty as ObjectPatternProperty, type nodes_Pattern as Pattern, nodes_PrivateIdentifier as PrivateIdentifier, nodes_Program as Program, nodes_Property as Property, nodes_PropertyDefinition as PropertyDefinition, type nodes_PropertyKey as PropertyKey, type nodes_PropertyValue as PropertyValue, nodes_RegexLiteral as RegexLiteral, nodes_RestElement as RestElement, nodes_ReturnStatement as ReturnStatement, nodes_Script as Script, nodes_SequenceExpression as SequenceExpression, nodes_SpreadElement as SpreadElement, type nodes_Statement as Statement, nodes_StaticBlock as StaticBlock, nodes_Super as Super, nodes_SwitchCase as SwitchCase, nodes_SwitchStatement as SwitchStatement, nodes_TaggedTemplateExpression as TaggedTemplateExpression, nodes_TemplateElement as TemplateElement, nodes_TemplateLiteral as TemplateLiteral, nodes_ThisExpression as ThisExpression, nodes_ThrowStatement as ThrowStatement, nodes_TryStatement as TryStatement, nodes_UnaryExpression as UnaryExpression, nodes_UpdateExpression as UpdateExpression, nodes_VariableDeclaration as VariableDeclaration, nodes_VariableDeclarator as VariableDeclarator, nodes_WhileStatement as WhileStatement, nodes_WithStatement as WithStatement, nodes_YieldExpression as YieldExpression };
}

interface Position {
    line: number;
    column: number;
}
interface SourceLocation {
    start: Position;
    end: Position;
    source?: string;
}

interface Config {
    range?: boolean;
    loc?: boolean;
    source?: string | null;
    tokens?: boolean;
    comment?: boolean;
    tolerant?: boolean;
    jsx?: boolean;
    sourceType?: 'script' | 'module';
    attachComment?: boolean;
}
interface TokenEntry {
    type: string;
    value: string;
    regex?: {
        pattern: string;
        flags: string;
    };
    range?: [number, number];
    loc?: SourceLocation;
}

declare class Visitor {
    visit(node: Node): any;
    visitNodeList<T extends Node>(original: (T[] | null)): T[];
    visitAssignmentExpression(node: AssignmentExpression): any;
    visitAssignmentPattern(node: AssignmentPattern): any;
    visitArrayExpression(node: ArrayExpression): ArrayExpression;
    visitArrayPattern(node: ArrayPattern): ArrayPattern;
    visitArrowFunctionExpression(node: ArrowFunctionExpression): any;
    visitAwaitExpression(node: AwaitExpression): any;
    visitBlockStatement(node: BlockStatement): BlockStatement;
    visitBinaryExpression(node: BinaryExpression): any;
    visitBreakStatement(node: BreakStatement): any;
    visitCallExpression(node: CallExpression): any;
    visitCatchClause(node: CatchClause): any;
    visitChainExpression(node: ChainExpression): any;
    visitClassBody(node: ClassBody): ClassBody;
    visitClassDeclaration(node: ClassDeclaration): any;
    visitClassExpression(node: ClassExpression): any;
    visitConditionalExpression(node: ConditionalExpression): any;
    visitContinueStatement(node: ContinueStatement): any;
    visitDecorator(node: Decorator): any;
    visitDoWhileStatement(node: DoWhileStatement): any;
    visitDebuggerStatement(node: DebuggerStatement): DebuggerStatement;
    visitEmptyStatement(node: EmptyStatement): EmptyStatement;
    visitExportAllDeclaration(node: ExportAllDeclaration): any;
    visitExportDefaultDeclaration(node: ExportDefaultDeclaration): any;
    visitExportNamedDeclaration(node: ExportNamedDeclaration): any;
    visitExportSpecifier(node: ExportSpecifier): any;
    visitExpressionStatement(node: ExpressionStatement): any;
    visitForStatement(node: ForStatement): any;
    visitForOfStatement(node: ForOfStatement): any;
    visitForInStatement(node: ForInStatement): any;
    visitFunctionDeclaration(node: FunctionDeclaration): any;
    visitFunctionExpression(node: FunctionExpression): any;
    visitIdentifier(node: Identifier): Identifier;
    visitIfStatement(node: IfStatement): any;
    visitImportAttribute(node: ImportAttribute): any;
    visitImportExpression(node: ImportExpression): any;
    visitImportDeclaration(node: ImportDeclaration): any;
    visitImportDefaultSpecifier(node: ImportDefaultSpecifier): any;
    visitImportNamespaceSpecifier(node: ImportNamespaceSpecifier): any;
    visitImportSpecifier(node: ImportSpecifier): any;
    visitLiteral(node: Literal | RegexLiteral): Literal | RegexLiteral;
    visitLabeledStatement(node: LabeledStatement): any;
    visitLogicalExpression(node: LogicalExpression): any;
    visitMemberExpression(node: MemberExpression): any;
    visitMetaProperty(node: MetaProperty): any;
    visitMethodDefinition(node: MethodDefinition): any;
    visitNewExpression(node: NewExpression): any;
    visitObjectExpression(node: ObjectExpression): ObjectExpression;
    visitObjectPattern(node: ObjectPattern): ObjectPattern;
    visitProgram(node: Program): Program;
    visitProperty(node: Property | PropertyDefinition): any;
    visitPrivateIdentifier(node: PrivateIdentifier): PrivateIdentifier;
    visitRestElement(node: RestElement): any;
    visitReturnStatement(node: ReturnStatement): any;
    visitSequenceExpression(node: SequenceExpression): SequenceExpression;
    visitSpreadElement(node: SpreadElement): any;
    visitStaticBlock(node: StaticBlock): StaticBlock;
    visitSuper(node: Super): Super;
    visitSwitchCase(node: SwitchCase): any;
    visitSwitchStatement(node: SwitchStatement): any;
    visitTaggedTemplateExpression(node: TaggedTemplateExpression): any;
    visitTemplateElement(node: TemplateElement): TemplateElement;
    visitTemplateLiteral(node: TemplateLiteral): TemplateLiteral;
    visitThisExpression(node: ThisExpression): ThisExpression;
    visitThrowStatement(node: ThrowStatement): any;
    visitTryStatement(node: TryStatement): any;
    visitUnaryExpression(node: UnaryExpression): any;
    visitUpdateExpression(node: UpdateExpression): any;
    visitVariableDeclaration(node: VariableDeclaration): VariableDeclaration;
    visitVariableDeclarator(node: VariableDeclarator): any;
    visitWhileStatement(node: WhileStatement): any;
    visitWithStatement(node: WithStatement): any;
    visitYieldExpression(node: YieldExpression): any;
}

declare function parse(code: string, options?: Config, delegate?: any): Program & {
    comments?: Comment[];
    tokens?: TokenEntry[];
    errors?: EsprimaError[];
};
declare function parseModule(code: string, options?: Config, delegate?: any): Program & {
    comments?: Comment[];
    tokens?: TokenEntry[];
    errors?: EsprimaError[];
};
declare function parseScript(code: string, options?: Config, delegate?: any): Program & {
    comments?: Comment[];
    tokens?: TokenEntry[];
    errors?: EsprimaError[];
};
declare function tokenize(code: string, options?: Config, delegate?: any): any;

declare const version = "6.0.2";
declare const _default: {
    parse: typeof parse;
    parseModule: typeof parseModule;
    parseScript: typeof parseScript;
    tokenize: typeof tokenize;
    Syntax: typeof Syntax;
    version: string;
};

export { type ArgumentListElement, ArrayExpression, type ArrayExpressionElement, ArrayPattern, type ArrayPatternElement, ArrowFunctionExpression, AssignmentExpression, AssignmentPattern, AsyncFunctionDeclaration, AwaitExpression, BigIntLiteral, BinaryExpression, type BindingIdentifier, type BindingPattern, BlockStatement, BreakStatement, CallExpression, CatchClause, type ChainElement, ChainExpression, type Class, ClassBody, ClassDeclaration, ClassExpression, ConditionalExpression, type Config, ContinueStatement, DebuggerStatement, type Declaration, Decorator, Directive, DoWhileStatement, EmptyStatement, ExportAllDeclaration, type ExportDeclaration, ExportDefaultDeclaration, ExportNamedDeclaration, ExportSpecifier, type ExportableDefaultDeclaration, type ExportableNamedDeclaration, type Expression, ExpressionStatement, ForInStatement, ForOfStatement, ForStatement, type Function, FunctionDeclaration, FunctionExpression, type FunctionParameter, Identifier, IfStatement, ImportAttribute, ImportDeclaration, type ImportDeclarationSpecifier, ImportDefaultSpecifier, ImportExpression, ImportNamespaceSpecifier, ImportSpecifier, LabeledStatement, Literal, LogicalExpression, MemberExpression, MetaProperty, MethodDefinition, Module, NewExpression, type Node, nodes as Nodes, ObjectExpression, type ObjectExpressionProperty, ObjectPattern, type ObjectPatternProperty, type Pattern, PrivateIdentifier, Program, Property, PropertyDefinition, type PropertyKey, type PropertyValue, RegexLiteral, RestElement, ReturnStatement, Script, SequenceExpression, SpreadElement, type Statement, StaticBlock, Super, SwitchCase, SwitchStatement, Syntax, TaggedTemplateExpression, TemplateElement, TemplateLiteral, ThisExpression, ThrowStatement, TryStatement, UnaryExpression, UpdateExpression, VariableDeclaration, VariableDeclarator, Visitor, WhileStatement, WithStatement, YieldExpression, _default as default, parse, parseModule, parseScript, tokenize, version };
